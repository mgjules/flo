package flo

import (
	"errors"
	"fmt"
	"reflect"
	"sync"

	"github.com/google/uuid"
	"github.com/rs/xid"
	"github.com/samber/lo"
)

// Flo is a fancy name for a bidirectional graph with some opionionated rules.
// It is essentially rendered as a wrapper function declaration.
// IOs are just the function parameters and return values.
// Nodes are called components and represent function calls.
type Flo struct {
	mu         sync.Mutex
	ID         uuid.UUID
	Components map[uuid.UUID]*Component
	IOs        IOs

	// handy to quickly find a connection details.
	connectionIndex map[uuid.UUID]*ComponentConnection
}

type Component struct {
	ID          uuid.UUID
	Name        string // func name retrieved from Value.
	Label       string
	Description string
	Value       reflect.Value // Enable use of instantiated object's methods or functions.
	IOs         IOs
}

type ComponentIO struct {
	ID          uuid.UUID
	Name        string // autogenerated short id used as variable name.
	Type        ComponentIOType
	RType       reflect.Type
	ParentID    uuid.UUID                          // Used for back reference.
	Connections map[uuid.UUID]*ComponentConnection // Many outgoing but one incoming.
}

type ComponentConnection struct {
	ID               uuid.UUID
	OutComponentID   uuid.UUID
	OutComponentIOID uuid.UUID
	InComponentID    uuid.UUID
	InComponentIOID  uuid.UUID
}

type IOs []*ComponentIO

type ComponentIOType int

const (
	ComponentIOTypeUnknown ComponentIOType = iota
	ComponentIOTypeIN
	ComponentIOTypeOUT
)

// NewFlo needs fn to make IOs creation much more pleasant.
func NewFlo(fn any) (*Flo, error) {
	f := Flo{
		ID:              uuid.New(),
		Components:      make(map[uuid.UUID]*Component),
		connectionIndex: make(map[uuid.UUID]*ComponentConnection),
	}

	ios, err := NewComponentIOsFromFunc(f.ID, reflect.ValueOf(fn))
	if err != nil {
		return nil, fmt.Errorf("cannot generate component ios: %v", err)
	}
	f.IOs = ios

	return &f, nil
}

func (f *Flo) AddComponent(c *Component) {
	if c == nil {
		return
	}

	f.mu.Lock()
	defer f.mu.Unlock()
	if _, found := f.Components[c.ID]; found {
		// don't override!
		return
	}
	f.Components[c.ID] = c
}

// ConnectComponent inter connects components or flos.
//
// Rules:
// 1. flo and component: IN(flo) -> IN(component) and OUT(component) -> OUT(flo).
// 2. component and component: OUT(component) -> IN(component).
func (f *Flo) ConnectComponent(
	outComponentID, outComponentIOID uuid.UUID,
	inComponentID, inComponentIOID uuid.UUID,
) error {
	if outComponentID == uuid.Nil {
		return errors.New("invalid out component id")
	}
	if outComponentIOID == uuid.Nil {
		return errors.New("invalid out component io id")
	}
	if inComponentID == uuid.Nil {
		return errors.New("invalid in component id")
	}
	if inComponentIOID == uuid.Nil {
		return errors.New("invalid in component io id")
	}

	f.mu.Lock()
	defer f.mu.Unlock()

	var outIOs IOs

	isFloOutgoing := outComponentID == f.ID
	if !isFloOutgoing {
		outComponent, found := f.Components[outComponentID]
		if !found {
			return fmt.Errorf("no out component id %q found in flo", outComponentID)
		}
		outIOs = outComponent.IOs
	} else {
		outIOs = f.IOs
	}
	outComponentIO, found := outIOs.GetByID(outComponentIOID)
	if !found {
		return fmt.Errorf("no component io id %q found on out component id %q", outComponentIOID, outComponentID)
	}

	var inIOs IOs

	isFloIngoing := inComponentID == f.ID
	if !isFloIngoing {
		inComponent, found := f.Components[inComponentID]
		if !found {
			return fmt.Errorf("no in component id %q found in flo", outComponentID)
		}
		inIOs = inComponent.IOs
	} else {
		inIOs = f.IOs
	}
	inComponentIO, found := inIOs.GetByID(inComponentIOID)
	if !found {
		return fmt.Errorf("no component io id %q found on in component id %q", inComponentIOID, inComponentID)
	}

	// We can't handle cyclic right now.
	if outComponentID == inComponentID {
		return fmt.Errorf("component id %q cannot connect to itself", outComponentID)
	}

	// Remember that if the component is a flo we inverse the flow check ;) (no pun intended).
	if !isFloOutgoing && outComponentIO.Type != ComponentIOTypeOUT {
		return fmt.Errorf("out component io id %q is not of type out", outComponentIOID)
	} else if isFloOutgoing && outComponentIO.Type != ComponentIOTypeIN {
		return fmt.Errorf("out flo io id %q is not of type in", outComponentIOID)
	}
	if !isFloIngoing && inComponentIO.Type != ComponentIOTypeIN {
		return fmt.Errorf("out component io id %q is not of type in", inComponentIOID)
	} else if isFloIngoing && inComponentIO.Type != ComponentIOTypeOUT {
		return fmt.Errorf("out flo io id %q is not of type out", inComponentIOID)
	}

	if len(inComponentIO.Connections) > 0 {
		return fmt.Errorf("in component io id %q already has a connection", inComponentIOID)
	}

	_, found = lo.Find(outIOs, func(io *ComponentIO) bool {
		if io == nil ||
			(!isFloOutgoing && io.Type != ComponentIOTypeOUT) ||
			(isFloOutgoing && io.Type != ComponentIOTypeIN) {
			return false
		}

		_, found := lo.FindKeyBy(io.Connections, func(id uuid.UUID, conn *ComponentConnection) bool {
			if conn == nil {
				return false
			}

			return conn.InComponentIOID == inComponentIO.ID
		})

		return found
	})
	if found {
		return fmt.Errorf(
			"in component id %q already has a connection with out component id %q through io id %q",
			inComponentID,
			outComponentID,
			outComponentIOID,
		)
	}

	// TODO: this might need more work than it look.
	if !outComponentIO.RType.AssignableTo(inComponentIO.RType) {
		return fmt.Errorf(
			"out component io id %q cannot be assigned to component io id %q",
			outComponentIOID,
			inComponentIOID,
		)
	}

	conn, err := NewComponentConnect(
		outComponentID, outComponentIOID,
		inComponentID, inComponentIOID,
	)
	if err != nil {
		return fmt.Errorf(
			"cannot create component connection: %v",
			err,
		)
	}

	if outComponentIO.Connections == nil {
		outComponentIO.Connections = make(map[uuid.UUID]*ComponentConnection)
	}
	if inComponentIO.Connections == nil {
		inComponentIO.Connections = make(map[uuid.UUID]*ComponentConnection)
	}

	outComponentIO.Connections[conn.ID] = conn
	inComponentIO.Connections[conn.ID] = conn
	f.connectionIndex[conn.ID] = conn

	if len(outComponentIO.Connections) == 1 {
		outComponentIO.Name = `f` + xid.New().String()
	}
	inComponentIO.Name = outComponentIO.Name

	return nil
}

func (f *Flo) DeleteConnection(connectionID uuid.UUID) error {
	if connectionID == uuid.Nil {
		return errors.New("invalid connnection id")
	}

	f.mu.Lock()
	defer f.mu.Unlock()

	conn, found := f.connectionIndex[connectionID]
	if !found {
		return fmt.Errorf("unknown connection id %q", connectionID)
	}

	defer delete(f.connectionIndex, connectionID)

	outComponent, found := f.Components[conn.OutComponentID]
	if !found {
		return fmt.Errorf("no out component id %q found in flo", conn.OutComponentID)
	}
	outComponentIO, found := outComponent.IOs.GetByID(conn.OutComponentIOID)
	if !found {
		return fmt.Errorf("no component io id %q found on out component id %q", conn.OutComponentIOID, conn.OutComponentID)
	}

	delete(outComponentIO.Connections, connectionID)

	inComponent, found := f.Components[conn.InComponentID]
	if !found {
		return fmt.Errorf("no in component id %q found in flo", conn.OutComponentID)
	}
	inComponentIO, found := inComponent.IOs.GetByID(conn.InComponentIOID)
	if !found {
		return fmt.Errorf("no component io id %q found on in component id %q", conn.InComponentIOID, conn.InComponentID)
	}

	delete(inComponentIO.Connections, connectionID)

	return nil
}

func NewComponent(
	label, description string,
	fn any,
) (*Component, error) {
	c := Component{
		ID:          uuid.New(),
		Label:       label,
		Description: description,
		Value:       reflect.ValueOf(fn),
	}

	ios, err := NewComponentIOsFromFunc(c.ID, c.Value)
	if err != nil {
		return nil, fmt.Errorf("cannot generate component ios: %v", err)
	}
	c.IOs = ios

	c.Name = c.Value.Type().Name()
	if c.Name == "" {
		c.Name = xid.New().String()
	}

	return &c, nil
}

func NewComponentIO(
	typ ComponentIOType,
	rType reflect.Type,
	parentID uuid.UUID,
) (*ComponentIO, error) {
	if typ == ComponentIOTypeUnknown {
		return nil, errors.New("unknown component io type")
	}
	if rType == nil || rType.Kind() == reflect.Invalid {
		return nil, errors.New("invalid component io reflect type")
	}
	if parentID == uuid.Nil {
		return nil, errors.New("invalid parent ID")
	}

	return &ComponentIO{
		ID:       uuid.New(),
		Type:     typ,
		RType:    rType,
		ParentID: parentID,
	}, nil
}

func NewComponentIOsFromFunc(parentID uuid.UUID, v reflect.Value) ([]*ComponentIO, error) {
	if parentID == uuid.Nil {
		return nil, errors.New("invalid parent ID")
	}
	if !v.IsValid() || v.Kind() != reflect.Func {
		return nil, fmt.Errorf("value of type %q must be a function", v.Kind())
	}

	vt := v.Type()
	ios := make([]*ComponentIO, 0, vt.NumIn()+vt.NumOut())
	for i := 0; i < vt.NumIn(); i++ {
		p := vt.In(i)
		e, err := NewComponentIO(
			ComponentIOTypeIN,
			p,
			parentID,
		)
		if err != nil {
			return nil, fmt.Errorf("unexpected error for argument %d: %w", i+1, err)
		}

		ios = append(ios, e)
	}

	for i := 0; i < vt.NumOut(); i++ {
		r := vt.Out(i)
		e, err := NewComponentIO(
			ComponentIOTypeOUT,
			r,
			parentID,
		)
		if err != nil {
			return nil, fmt.Errorf("unexpected error for return value %d: %w", i+1, err)
		}

		ios = append(ios, e)
	}

	return ios, nil
}

func NewComponentConnect(
	outComponentID uuid.UUID,
	outComponentIOID uuid.UUID,
	inComponentID uuid.UUID,
	inComponentIOID uuid.UUID,
) (*ComponentConnection, error) {
	if outComponentID == uuid.Nil {
		return nil, errors.New("invalid out component id")
	}
	if outComponentIOID == uuid.Nil {
		return nil, errors.New("invalid out component io id")
	}
	if inComponentID == uuid.Nil {
		return nil, errors.New("invalid in component id")
	}
	if inComponentIOID == uuid.Nil {
		return nil, errors.New("invalid in component io id")
	}

	return &ComponentConnection{
		ID:               uuid.New(),
		OutComponentID:   outComponentID,
		OutComponentIOID: outComponentIOID,
		InComponentID:    inComponentID,
		InComponentIOID:  inComponentIOID,
	}, nil
}

func (ios IOs) GetByID(id uuid.UUID) (*ComponentIO, bool) {
	if ios == nil || id == uuid.Nil {
		return nil, false
	}

	return lo.Find(ios, func(io *ComponentIO) bool {
		if io == nil {
			return false
		}

		return io.ID == id
	})
}
